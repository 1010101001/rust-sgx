/*
 * Bare-bones SGX EPC driver. Exposes ENCLS pretty much directly to userspace.
 * Not intended for production use.
 *
 * (C) Copyright 2015 Jethro G. Beekman
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; version 2
 * of the License.
 */

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/notifier.h>
#include <linux/kdebug.h>
#include <linux/mm.h>
#include <asm/asm.h>
#include <asm/traps.h>
#include <asm/uaccess.h>

#include "sgx.h"

// ===user ABI===

struct sgx_ioctl_data {
	union {
		struct {
			unsigned long rbx;
			unsigned long rcx;
			unsigned long rdx;
		} /*in*/;
		struct {
			int exception;
			unsigned long data;
		} /*out*/;
	};
};

/// ENCLS ioctl
/// Select leaf by IOCTL request code.
/// Currently only ECREATE, EADD, EEXTEND, EINIT, EREMOVE, EBLOCK are supported.
///
/// IN:
///   .rbx          RBX register contents for ENCLS
///   .rcx          RCX register contents for ENCLS
///   .rdx          RDX register contents for ENCLS
/// OUT:
///   .exception    Trap number if exception occurred, -1 otherwise
///   .data         Additional information if exception occured,
///                 EAX output otherwise

#define SGX_IOCTL 'G'
#define ENCLS_ECREATE_IOCTL _IOWR(SGX_IOCTL, 0x00, struct sgx_ioctl_data)
#define ENCLS_EADD_IOCTL    _IOWR(SGX_IOCTL, 0x01, struct sgx_ioctl_data)
#define ENCLS_EINIT_IOCTL   _IOWR(SGX_IOCTL, 0x02, struct sgx_ioctl_data)
#define ENCLS_EREMOVE_IOCTL _IOWR(SGX_IOCTL, 0x03, struct sgx_ioctl_data)
#define ENCLS_EDBGRD_IOCTL  _IOWR(SGX_IOCTL, 0x04, struct sgx_ioctl_data)
#define ENCLS_EDBGWR_IOCTL  _IOWR(SGX_IOCTL, 0x05, struct sgx_ioctl_data)
#define ENCLS_EEXTEND_IOCTL _IOWR(SGX_IOCTL, 0x06, struct sgx_ioctl_data)
#define ENCLS_ELDB_IOCTL    _IOWR(SGX_IOCTL, 0x07, struct sgx_ioctl_data)
#define ENCLS_ELDU_IOCTL    _IOWR(SGX_IOCTL, 0x08, struct sgx_ioctl_data)
#define ENCLS_EBLOCK_IOCTL  _IOWR(SGX_IOCTL, 0x09, struct sgx_ioctl_data)
#define ENCLS_EPA_IOCTL     _IOWR(SGX_IOCTL, 0x0a, struct sgx_ioctl_data)
#define ENCLS_EWB_IOCTL     _IOWR(SGX_IOCTL, 0x0b, struct sgx_ioctl_data)
#define ENCLS_ETRACK_IOCTL  _IOWR(SGX_IOCTL, 0x0c, struct sgx_ioctl_data)
#define ENCLS_EAUG_IOCTL    _IOWR(SGX_IOCTL, 0x0d, struct sgx_ioctl_data)
#define ENCLS_EMODPR_IOCTL  _IOWR(SGX_IOCTL, 0x0e, struct sgx_ioctl_data)
#define ENCLS_EMODT_IOCTL   _IOWR(SGX_IOCTL, 0x0f, struct sgx_ioctl_data)

/// SGX_IOADDR ioctl
/// returns the kernel address of the start of the EPC
///
/// IN: (no inputs)
/// OUT:
///   .exception    -1
///   .data         kernel virtual address of EPC

#define SGX_META_IOCTL 'H'
#define SGX_IOADDR_IOCTL _IOW(SGX_META_IOCTL, 0x00, struct sgx_ioctl_data)

// ===global state===
static int major;
static void* epcmem;

// TODO: get this information from CPUID 0x12/ACPI device INT0E0C
static inline unsigned long epc_start(void) { return 0x80200000UL; }
static inline unsigned long epc_len(void) { return 0x05d80000UL; }

// ===ENCLS call architecture===

// The ENCLS call is guarded to gracefully stop exceptions. This is built on
// the die_notifier primitives. Fixups can't be used since there is no way to
// distinguish between exception types. There is only a single instance of the
// ENCLS opcode, defined in encls.S. The notifier callback checks if the
// exception was generated by that instructions address. If so, execution is
// resumed at the next instruction.

extern void encls_might_fault;
extern void encls_after_fault;

static struct {
	int trapnr;
	long error_code;
	unsigned long cr2;
	unsigned long reason;
	int triggered;
} die_info;

static int sgx_die_notify(struct notifier_block *, unsigned long, void *);
static struct notifier_block sgx_die_notifier = {
	.notifier_call = sgx_die_notify,
};

static int sgx_die_notify(struct notifier_block *nb, unsigned long event, void *_die_args)
{
	struct die_args *die_args = _die_args;

	unsigned long cr2=read_cr2();
	//printk("[SGX] trap event=%lu trap=%u func=%p IP=%p cr2=%016lx\n",event,die_args->trapnr,&encls_might_fault,(void*)die_args->regs->ip,cr2);
	if (!die_info.triggered && &encls_might_fault==(void*)die_args->regs->ip) {
		die_args->regs->ip=(long)&encls_after_fault;
		die_info.trapnr=die_args->trapnr;
		die_info.error_code=die_args->err;
		die_info.reason=event;
		die_info.cr2=cr2;
		die_info.triggered=1;
		return NOTIFY_STOP;
	}

	return NOTIFY_DONE;
}

// ===IOCTL===

// We need to copy structures out of user space before executing ENCLS. Offsets
// to fit everything in a single page with proper alignment:
//   struct      size   align   offset
//   SIGSTRUCT   1808   4096    0
//   PAGEINFO    32     32      1824
//   SECINFO     64     64      1856
//   EINITTOKEN  304    512     2048
#define SIGSTRUCT_OFFSET   0
#define PAGEINFO_OFFSET    1824
#define SECINFO_OFFSET     1856
#define EINITTOKEN_OFFSET  2048

static unsigned long sgx_copy(unsigned long* pageptr,unsigned long offset,unsigned long src,unsigned long size) {
	unsigned long dst;
	if (!*pageptr)
		*pageptr=__get_free_page(GFP_KERNEL);
	if (!*pageptr)
		return 0;
	dst=(*pageptr)+offset;
	if (copy_from_user((void*)dst,(void*)src,size)!=0)
		return 0;
	return dst;
}

static long sgxdev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg) {
	switch (cmd) {
		case ENCLS_ECREATE_IOCTL:
		case ENCLS_EADD_IOCTL:
		case ENCLS_EEXTEND_IOCTL:
		case ENCLS_EINIT_IOCTL:
		case ENCLS_EREMOVE_IOCTL:
		case ENCLS_EBLOCK_IOCTL: {
			long result;
			long page1=0,page2=0;
			struct sgx_ioctl_data data;

			if (copy_from_user(&data, (void*)arg, sizeof(data))!=0)
				return -EFAULT;

			if (cmd==ENCLS_ECREATE_IOCTL || cmd==ENCLS_EADD_IOCTL) {
				pageinfo_t* pageinfo;
				pageinfo=(pageinfo_t*)(data.rbx=sgx_copy(&page1,PAGEINFO_OFFSET,data.rbx,sizeof(pageinfo_t)));
				pageinfo->secinfo=sgx_copy(&page1,SECINFO_OFFSET,pageinfo->secinfo,sizeof(secinfo_t));
				pageinfo->srcpge=sgx_copy(&page2,0,pageinfo->srcpge,4096);
			} else if (cmd==ENCLS_EINIT_IOCTL) {
				data.rbx=sgx_copy(&page1,SIGSTRUCT_OFFSET,data.rbx,sizeof(sigstruct_t));
				data.rdx=sgx_copy(&page1,EINITTOKEN_OFFSET,data.rdx,sizeof(einittoken_t));
			}

			//printk("[SGX] encls[%d] rcx=%p rbx=%p rdx=%p\n",_IOC_NR(cmd),(void*)data.rcx,(void*)data.rbx,(void*)data.rdx);
			die_info.triggered=0;
			unregister_die_notifier(&sgx_die_notifier);
			register_die_notifier(&sgx_die_notifier);
			asm volatile("    call encls_might_fault \n"
			             : "=a"(result)
			             : "a"(_IOC_NR(cmd)), "b"(data.rbx) , "c"(data.rcx) , "d"(data.rdx)
			             : );
			unregister_die_notifier(&sgx_die_notifier);
			if (die_info.triggered) {
				data.exception=die_info.trapnr;
				if (die_info.trapnr==X86_TRAP_PF)
					data.data=die_info.cr2;
				else if (die_info.trapnr==X86_TRAP_GP)
					data.data=die_info.error_code;
			} else {
				data.exception=-1;
				data.data=result;
			}

			if (page1) free_page(page1);
			if (page2) free_page(page2);

			if (copy_to_user((void*)arg,&data,sizeof(data))!=0)
				return -EFAULT;
			return 0;
		}
		case SGX_IOADDR_IOCTL: {
			struct sgx_ioctl_data data={
				.exception=-1,
				.data=(unsigned long)epcmem,
			};
			if (copy_to_user((char*)arg,&data,sizeof(data))!=0)
				return -EFAULT;
			return 0;
		}
		default:
			return -ENOTTY;
	}
}

// ===mmap===

static int sgxdev_mmap(struct file *filep, struct vm_area_struct *vma) {
	return vm_iomap_memory(vma,epc_start(),epc_len());
}

static unsigned long sgxdev_get_unmapped_area(struct file *filep, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags) {
	// make sure any map placed by the kernel is naturally aligned
	unsigned long area=current->mm->get_unmapped_area(filep,addr,len*2,pgoff,flags);
	if (IS_ERR_VALUE(area))
		return area;
	return (area+len)&~(len-1);
}

// ===module glue===

static struct file_operations fops = {
	.unlocked_ioctl = sgxdev_ioctl,
	.mmap = sgxdev_mmap,
	.get_unmapped_area = sgxdev_get_unmapped_area,
};

static int __init sgxdev_module_init(void) {
	major = register_chrdev(0, "sgxdev", &fops);
	epcmem=ioremap(epc_start(),epc_len());
	if (major < 0) {
		printk ("[SGX] Registering the character device failed with %d\n", major);
		return major;
	}
	printk("[SGX] create node with: sudo mknod -m 666 /dev/sgx c %d 0\n", major);
	return 0;
}

static void __exit sgxdev_module_exit(void) {
	iounmap(epcmem);
	unregister_die_notifier(&sgx_die_notifier);
	unregister_chrdev(major, "sgxdev");
	printk("[SGX] unloaded\n");
}

module_init(sgxdev_module_init);
module_exit(sgxdev_module_exit);
MODULE_LICENSE("GPL");
